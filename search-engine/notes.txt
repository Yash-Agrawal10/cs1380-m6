IDEA FOUR: Combined map-reduce

Idea:
    Use map-reduce only for indexing
    Completely separate crawler, indexer, Queryer

Crawler:
    One manager node manages urlList and visitedList
        Has a function getURLs that verifies URL is not seen
        Has a function putURLs that appends to URLs
        Could maintain lists in memory, but write persistently for fault tolerance
    Many nodes actually crawl
        Use getURL to collect URLs from crawl manager
        Downloads content
        Saves text on index group
        Extracts URLs and appends them to crawl manager and index manager

Indexer:
    One manager node manages toIndex list
        Initializes map-reduce computation on worker group
    Many nodes actually index
        Map - consume (and delete) downloaded text, emit {term: url, freq}
        Reduce - append list of {url, freq} to global index distributed over queryers and sort it

Queryer:
    Many nodes store global index
    When queried, simply get global index and return top results



Details:

    Crawler:
        Orchestrator -- 
            1. Define groups/nodes (crawler group, index orchestrator, index group)
            2. Spawn crawler group (manual or programmatic), tell them to run crawl function
            3. Initialize seed list if it doens't exist
            4. Nothing (service crawler group requests, also add used URLs to visited list)
        Worker -- 
            1. Pop url(s) to crawl from orchestrator
            (For each url)
            2. Fetch HTML data from webpage
            3. Extract text and store to crawler group (with url as name)
            4. Extract URLs and have orchestrator append them
            5. Repeat

    Indexer:
        Orchestrator -- 
            1. Get n urls from the toIndex list
            2. Call map-reduce on index worker group with urls as keys
            3. Repeat
        Worker -- 
            Map - consumes url data, emits {term: {url, frequency}} objects, does n-grams (at some point)
            Reduce - Append [{url, freq}] to global index (stored on queryers (for now)), sorts it?
    
    Queryer:
        One script that is a command line tool which just queries global index using store.all.get
        Nodes to store index maybe?